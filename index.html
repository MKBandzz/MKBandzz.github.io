<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>MKB City Map</title>

<meta name="viewport" content="width=device-width, initial-scale=1" />

<!-- OpenLayers -->
<script src="https://cdn.jsdelivr.net/npm/ol@7.4.0/dist/ol.js"></script>

<!-- Unmined files (ROOT-relative) -->
<script src="./unmined.openlayers.js"></script>
<script src="./unmined.map.properties.js"></script>
<script src="./unmined.map.regions.js"></script>

<style>
html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  background: #000;
}
#map {
  width: 100%;
  height: 100%;
}
.popup {
  background: white;
  padding: 6px 8px;
  border-radius: 4px;
  font-size: 13px;
}
</style>
</head>

<body>
<div id="map"></div>

<script>
/* ===============================
   Initialize Unmined base map
================================ */
const unmined = new Unmined();
unmined.map("map", UnminedMapProperties, UnminedRegions);

const map = unmined.openlayersMap;

/* ===============================
   Projections (MATCH Unmined)
================================ */
const viewProjection = new ol.proj.Projection({
  code: 'VIEW',
  units: 'pixels'
});
const dataProjection = new ol.proj.Projection({
  code: 'DATA',
  units: 'pixels'
});

ol.proj.addCoordinateTransforms(
  viewProjection,
  dataProjection,
  c => [c[0], -c[1]],
  c => [c[0], -c[1]]
);

function xyToView(x, y) {
  // GeoJSON: [x,y] â†’ Map: [x,z]
  return ol.proj.transform([x, y], dataProjection, viewProjection);
}

/* ===============================
   Roads layer
================================ */
const roadSource = new ol.source.Vector();
const roadLayer = new ol.layer.Vector({
  source: roadSource,
  style: f => {
    const t = f.get('Type');
    let color = 'gray', width = 2;
    if (t === 'Highway' || t === 'Ramp') { color = 'yellow'; width = 6; }
    else if (t === 'Road' || t === 'Arterial') { color = 'white'; width = 4; }
    return new ol.style.Style({
      stroke: new ol.style.Stroke({ color, width })
    });
  }
});
map.addLayer(roadLayer);

fetch('./roads.geojson')
  .then(r => r.json())
  .then(g => {
    g.features.forEach(f => {
      const coords = f.geometry.coordinates.map(p => xyToView(p[0], p[1]));
      const feat = new ol.Feature({
        geometry: new ol.geom.LineString(coords),
        ...f.properties
      });
      roadSource.addFeature(feat);
    });
    console.log("Roads loaded:", roadSource.getFeatures().length);
  });

/* ===============================
   Properties (POIs)
================================ */
const poiSource = new ol.source.Vector();
const poiLayer = new ol.layer.Vector({
  source: poiSource,
  style: f => new ol.style.Style({
    image: new ol.style.Circle({
      radius: 6,
      fill: new ol.style.Fill({ color: 'red' }),
      stroke: new ol.style.Stroke({ color: '#000', width: 1 })
    })
  })
});
map.addLayer(poiLayer);

fetch('./properties.geojson')
  .then(r => r.json())
  .then(g => {
    g.features.forEach(f => {
      if (f.geometry.type !== 'Polygon') return;

      const ring = f.geometry.coordinates[0];
      let sx = 0, sy = 0;
      ring.forEach(p => { sx += p[0]; sy += p[1]; });
      const cx = sx / ring.length;
      const cy = sy / ring.length;

      const point = new ol.Feature({
        geometry: new ol.geom.Point(xyToView(cx, cy)),
        Name: f.properties.Name,
        Type: f.properties.Type
      });

      poiSource.addFeature(point);
    });
    console.log("POIs loaded:", poiSource.getFeatures().length);
  });

/* ===============================
   Click popup
================================ */
const overlayEl = document.createElement('div');
overlayEl.className = 'popup';
const overlay = new ol.Overlay({ element: overlayEl, offset: [0, -10] });
map.addOverlay(overlay);

map.on('singleclick', e => {
  overlay.setPosition(undefined);
  map.forEachFeatureAtPixel(e.pixel, f => {
    overlayEl.innerHTML =
      `<b>${f.get('Name') || ''}</b><br>${f.get('Type') || ''}`;
    overlay.setPosition(e.coordinate);
    return true;
  });
});
</script>
</body>
</html>
